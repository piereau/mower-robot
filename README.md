# RoboMower Dashboard

Mobile-first web application for monitoring and controlling an autonomous lawn mower robot powered by Raspberry Pi.

> **Current Phase:** POC in simulation mode — robot hardware not yet available.

---

## Table of Contents

1. [Getting Started](#getting-started)
2. [Project Overview](#project-overview)
3. [POC Scope](#poc-scope)
4. [Technical Stack](#technical-stack)
5. [Architecture](#architecture)
6. [API Contracts](#api-contracts)
7. [Project Structure](#project-structure)
8. [Development Guidelines](#development-guidelines)
9. [UI/UX Guidelines](#uiux-guidelines)
10. [Roadmap](#roadmap)


---

## Getting Started

### Prerequisites

- Node.js 18+
- pnpm
- Python 3.11+

### Frontend Setup

```bash
cd apps/frontend

# Install dependencies
pnpm install

# Start dev server
pnpm dev
```

### Backend Setup

```bash
cd apps/backend

# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Start server
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

### Deploy to Raspberry Pi

```bash
# Set RPi IP address
export RPI_HOST=192.168.1.28

# Deploy (rsync mode)
./deploy/rpi.sh

# See deploy/README.md for full setup instructions
```

### Environment Variables

**Frontend (`.env`):**

```env
VITE_WS_URL=ws://localhost:8000/ws/robot
VITE_API_URL=http://localhost:8000
```

**Backend (`.env`):**

```env
SIMULATION_INTERVAL=2.0
USE_MOCK_GPIO=true
```

---

## Project Overview

### Context

This project aims to build a control and monitoring interface for an autonomous lawn mower robot. The robot is built on a Raspberry Pi with GPIO-controlled servomotors and sensors.

### Goals

- **Real-time monitoring:** Display robot state, battery level, and other vitals
- **Future control:** Start, stop, and configure autonomous mowing sessions
- **Field-ready UX:** Simple, readable interface optimized for outdoor smartphone use
- **Modular architecture:** Clean separation of concerns for easy evolution

### Hardware (Target)

| Component | Description |
|-----------|-------------|
| Raspberry Pi | Main controller running the backend |
| GPIO | Interface for servomotors and sensors |
| WiFi | Network connectivity for app communication |

---

## POC Scope

The POC focuses on **User Story #2: Real-time robot status**.

### In Scope (v1)

- WebSocket connection for real-time telemetry
- Display robot state (`idle`, `mowing`, `error`)
- Display battery percentage (0–100%)

### Out of Scope (for now)

- Motor control commands
- Scheduling and automation
- Authentication
- Persistent data storage

### Simulated Telemetry

Since the robot is not available, the backend generates mock telemetry data:

| Field | Type | Values |
|-------|------|--------|
| `state` | enum | `idle`, `mowing`, `error` |
| `battery` | number | 0–100 |

---

## Technical Stack

### Backend

| Technology | Purpose |
|------------|---------|
| **Python 3.11+** | Runtime |
| **FastAPI** | REST API framework |
| **WebSocket** | Real-time communication |
| **Pydantic** | Data validation and models |
| **uvicorn** | ASGI server |

### Frontend

| Technology | Purpose |
|------------|---------|
| **React 18** | UI framework |
| **TypeScript** | Type safety |
| **Vite** | Build tool and dev server |
| **Tailwind CSS** | Utility-first styling |
| **Native WebSocket** | Real-time data subscription |

### Tooling

| Tool | Purpose |
|------|---------|
| **pnpm** | Frontend package manager |
| **ESLint** | Code linting |
| **Prettier** | Code formatting |

---

## Architecture

### Backend Architecture

The backend follows a layered architecture with clear separation of concerns.

**Layers:**

| Layer | Responsibility |
|-------|----------------|
| `api/` | REST route handlers (thin controllers) |
| `ws/` | WebSocket route handlers |
| `domain/` | Business models, enums, validation |
| `simulation/` | Telemetry generation for POC |
| `hardware/` | GPIO abstraction (mock + real implementations) |
| `settings.py` | Configuration and environment variables |

**Key Design Decisions:**

- **Hardware abstraction:** GPIO operations are hidden behind an interface. A mock implementation is used by default, allowing development without physical hardware.
- **Simulator service:** Telemetry data is generated by a dedicated simulator, not inline in route handlers.
- **Typed models:** All data structures use Pydantic models with explicit types and validation.

### Frontend Architecture

The frontend follows a feature-based modular architecture.

**Layers:**

| Layer | Responsibility |
|-------|----------------|
| `pages/` | Screen composition, layout |
| `components/` | Reusable UI components (cards, badges, indicators) |
| `hooks/` | State management, WebSocket subscription |
| `services/` | Network clients (WebSocket, REST) |
| `types/` | TypeScript interfaces and types |
| `utils/` | Pure utility functions (formatting, mapping) |

**Key Design Decisions:**

- **Presentational components:** UI components are kept "dumb" — they receive props and render. Logic lives in hooks.
- **Single WebSocket client:** One module manages the WebSocket connection. Components subscribe via hooks.
- **Reconnection handling:** The WebSocket hook manages reconnection attempts and exposes connection state.
- **Last-known state:** When disconnected, the UI shows the last received data with a stale indicator.

### Data Flow

**Real-time Telemetry Flow:**

1. Backend simulator generates telemetry at regular intervals
2. Backend broadcasts telemetry via WebSocket to connected clients
3. Frontend WebSocket service receives the message
4. `useRobotTelemetry` hook updates state
5. Dashboard components re-render with new data

**Connection State Flow:**

1. WebSocket client emits connection events (`open`, `close`, `error`)
2. Hook tracks connection state
3. UI displays appropriate status (connected/disconnected indicator)
4. On disconnect, automatic reconnection attempts begin

---

## API Contracts

### WebSocket Endpoint

**URL:** `ws://<host>/ws/robot`

**Direction:** Server → Client (push)

**Message Format:**

```json
{
  "state": "mowing",
  "battery": 76
}
```

**TypeScript Interface:**

```typescript
type RobotState = 'idle' | 'mowing' | 'error';

interface RobotTelemetry {
  state: RobotState;
  battery: number;
  timestamp: string;
}
```

### REST Endpoints

| Method | Path | Description |
|--------|------|-------------|
| GET | `/health` | Health check (returns `{ status: "ok" }`) |
| GET | `/robot/status` | Last known robot state (optional, for initial load) |

---

## Project Structure

```
mower-roboto/
├── apps/
│   ├── backend/                 # Python FastAPI → deploys to RPi
│   │   ├── app/
│   │   │   ├── main.py          # FastAPI entrypoint
│   │   │   ├── api/             # REST endpoints
│   │   │   ├── ws/              # WebSocket handlers
│   │   │   ├── domain/          # Models & enums
│   │   │   ├── control/         # Motor control
│   │   │   ├── camera/          # Camera streaming
│   │   │   └── settings.py      # Configuration
│   │   └── requirements.txt
│   │
│   ├── frontend/                # React/Vite → runs on PC/browser
│   │   ├── src/
│   │   │   ├── pages/           # Dashboard, ScheduleForm
│   │   │   ├── components/      # UI components
│   │   │   ├── hooks/           # useRobotTelemetry, useRobotControl
│   │   │   ├── services/        # wsClient
│   │   │   └── types/           # TypeScript interfaces
│   │   ├── package.json
│   │   └── vite.config.ts
│   │
│   └── ros2/                    # ROS 2 workspace → deploys to RPi (future)
│       └── src/
│
├── embedded/
│   └── arduino/                 # Arduino sketches → flashed via USB
│       └── robot_mower.ino
│
├── deploy/                      # Deployment scripts & configs
│   ├── rpi.sh                   # Main deploy script
│   ├── services/                # systemd unit files
│   └── README.md
│
├── shared/                      # Shared types/contracts
│   └── types/
│
├── docs/                        # Documentation
│
├── _bmad/                       # BMAD workflow templates
├── _bmad-output/                # Planning artifacts (PRD, Architecture, Epics)
│
└── README.md
```

### Deployment Targets

| Component | Location | Deploys To |
|-----------|----------|------------|
| Backend | `apps/backend/` | Raspberry Pi |
| Frontend | `apps/frontend/` | Local dev / CDN |
| ROS 2 | `apps/ros2/` | Raspberry Pi |
| Arduino | `embedded/arduino/` | Arduino (via USB) |

---

## Development Guidelines

### General Principles

1. **POC mindset:** Keep it simple. Avoid over-engineering.
2. **Separation of concerns:** Each layer has one job.
3. **Explicit over implicit:** Prefer verbose, clear code over clever shortcuts.
4. **Incremental iteration:** Ship small, working increments.

### Backend Guidelines

**Code Organization:**

- Route handlers are thin — delegate logic to services
- All models use Pydantic with explicit types
- Enums for all finite state values
- No business logic in `main.py`

**Hardware Abstraction:**

- Define interfaces in `hardware/interfaces.py`
- Default to mock implementation
- Real GPIO implementation must be optional (not required to run locally)

**Simulation:**

- Telemetry simulator is a standalone service
- Configurable intervals and value ranges
- Deterministic testing mode available

**Error Handling:**

- All network operations wrapped in try/except
- Log errors with context
- Return meaningful error responses

### Frontend Guidelines

**Component Design:**

- Components are presentational (receive props, render UI)
- No direct API calls in components
- Use TypeScript for all files

**State Management:**

- Use React hooks for local state
- WebSocket state managed in dedicated hook
- No global state library for POC (keep it simple)

**Styling with Tailwind:**

- Use Tailwind utility classes exclusively
- Define semantic class combinations in components
- Maintain consistent spacing scale (4, 8, 12, 16, 24, 32px)
- Use Tailwind's color palette for consistency

**WebSocket Handling:**

- Single WebSocket client module
- Hook manages subscription lifecycle
- Automatic reconnection with exponential backoff
- Expose connection state to UI

**Error Handling:**

- Display user-friendly error states
- Show offline indicator when disconnected
- Preserve last-known data when connection drops

### Naming Conventions

| Context | Convention | Example |
|---------|------------|---------|
| React components | PascalCase | `StatusCard.tsx` |
| Hooks | camelCase with `use` prefix | `useRobotTelemetry.ts` |
| Services | camelCase | `wsClient.ts` |
| Python modules | snake_case | `mock_gpio.py` |
| TypeScript interfaces | PascalCase | `RobotTelemetry` |
| CSS classes | Tailwind utilities | `bg-blue-500 p-4 rounded-lg` |

### Testing Strategy

**Backend:**

- Unit tests for simulator (value ranges, state transitions)
- Integration tests for WebSocket connection

**Frontend:**

- Unit tests for utility functions (formatters)
- Component tests for critical UI states (connected, disconnected, error)

---

## UI/UX Guidelines

### Design Philosophy

The UI is inspired by the reference design (`dashboard.png`) — clean, card-based, with clear visual hierarchy.

### Design Tokens

**Color Palette:**

| Token | Tailwind Class | Usage |
|-------|----------------|-------|
| Background | `bg-slate-100` | Page background |
| Card | `bg-white` | Card surfaces |
| Primary | `text-slate-900` | Headings, primary text |
| Secondary | `text-slate-500` | Labels, secondary text |
| Success | `text-emerald-500` | Online, idle state |
| Warning | `text-amber-500` | Low battery |
| Error | `text-red-500` | Error state, offline |
| Accent | `bg-slate-800` | Buttons, active elements |

**Typography:**

| Element | Classes |
|---------|---------|
| Page title | `text-2xl font-bold text-slate-900` |
| Card title | `text-lg font-semibold text-slate-800` |
| Body text | `text-base text-slate-600` |
| Caption | `text-sm text-slate-500` |
| Badge | `text-xs font-medium uppercase` |

**Spacing:**

- Card padding: `p-4` (16px)
- Card gap: `gap-4` (16px)
- Section spacing: `space-y-6` (24px)

**Border Radius:**

- Cards: `rounded-2xl`
- Badges: `rounded-full`
- Buttons: `rounded-xl`

### Layout

- Mobile-first responsive design
- Single column layout on mobile
- Max content width: `max-w-md` centered
- Safe area padding: `px-4 py-6`

### States

**Connection States:**

| State | Indicator |
|-------|-----------|
| Connected | Green dot + "Online" badge |
| Disconnected | Red dot + "Offline" badge + dimmed UI |
| Reconnecting | Pulsing indicator + "Reconnecting..." |

**Robot States:**

| State | Visual |
|-------|--------|
| Idle | Green checkmark + "Standby" label |
| Mowing | Animated icon + "Mowing" label |
| Error | Red alert icon + "Error" label |

**Battery Levels:**

| Level | Color |
|-------|-------|
| 50-100% | Green (`text-emerald-500`) |
| 20-49% | Amber (`text-amber-500`) |
| 0-19% | Red (`text-red-500`) |

---

## Roadmap

### v1 — POC (Current)

- [x] Project setup (React + Vite + Tailwind)
- [x] Backend WebSocket endpoint with simulated telemetry
- [x] Frontend dashboard with real-time status cards
- [ ] Connection state handling (online/offline/reconnecting)
- [ ] Last update timestamp display

### v2 — Control

- [ ] Start/Stop commands via WebSocket
- [ ] Command acknowledgment (ack/nack)
- [ ] Mode selection (manual, auto)
- [ ] Light persistence (last known state)

### v3 — Hardware Integration

- [ ] Real GPIO implementation for Raspberry Pi
- [ ] Motor control integration
- [ ] Sensor data (obstacles, boundaries)
- [ ] Authentication and security

### v4 — Enhanced Features

- [ ] Scheduling system
- [ ] Mowing history
- [ ] Zone mapping
- [ ] Push notifications
